---
title: 广播接收器
date: 2018-08-21 18:39:25
tags: [广播]
categories: 安卓
---

**标准广播：**一种完全异步执行的广播，广播发出后，所有的接收器几乎同一时间接收到这条广播，效率较高
**有序广播：**一种同步执行的广播，广播发出后，同一时刻只会有一个广播接收器收到这条广播，当这个广播接收器中的逻辑执行完毕后，广播才会继续传递。优先级高的广播可以优先收到广播消息，并且可以在广播的重写方法`onReceive()`中使用`abortBroadcast();`方法截断正在传递的广播


## 接收广播
需要先能接收广播，发送广播的消息才可以监听到。接收广播有两种方式，一种是动态注册，一种是静态注册。
新建广播接收器，右键单机包名 -> New -> Other -> Broadcast Receiver或者直接创建内部类继承自`BroadcastReceiver`
<!--more-->
### 静态注册
在`AndroidMainifest.xml`文件中进行注册。如下：

```
<receiver
    android:name=".MyReceiver"
    android:enabled="true"
    android:exported="true">
    <intent-filter android:priority="100">
        <action android:name="com.example.Receiver.Myreceiver"></action>
    </intent-filter>
</receiver>
```

`android:name`: 广播类名
`enabled`: 是否启用这个广播接收器
`exported`: 是否允许这个广播接收器接收本程序以外的广播
`android:priority`: 广播接收器的优先级，有序广播下，优先级越高，越先监听到广播消息
`action`: 广播名称

### 动态注册
创建`MyReceiver`类，继承自`BroadcastReceiver`,重写`onReceive()`方法，在这个方法中处理一些逻辑问题。

```
public class MyReceiver extends BroadcastReceiver {
    // 广播名称
    public static  final String ACTION = "com.example.dym.receiver.Action.MyReceiver";
    @Override
    public void onReceive(Context context, Intent intent) {
    //在此处处理逻辑，不能处理太耗时的逻辑，如果有耗时操作，加入后台处理
        System.out.println("接收到了消息 " + intent.getStringExtra("data"));
    }
}
```

在`MainActivity`中有三个按钮，用来发送消息、注册、注销，广播接听器需要主动注销或者在`onDestroy()`方法中注销

```
   // 添加一个私有变量 
    private MyReceiver receiver = null;
    @Override
    protected void onDestroy() {
        super.onDestroy();
        unregisterReceiver(receiver);
    }

    @Override
    public void onClick(View v) {
        switch (v.getId()){
            case R.id.sendMessage: //发送消息
                Intent i = new Intent(MyReceiver.ACTION);
                i.putExtra("data","value");
                sendBroadcast(i);
                break;
             case R.id.registerService: //注册
                if (receiver == null){
                    receiver = new MyReceiver();
                    registerReceiver(receiver,new IntentFilter(MyReceiver.ACTION));
                }
                break;
            case R.id.unregisterService: //注销
                if (receiver != null){
                    unregisterReceiver(receiver);
                    receiver = null;
                }
                break;
            default:
                    break;
        }
    }

```
 动态注册需要调用`registerReceiver()`方法，第一参数传receiver，第二个参数传IntentFilter，在IntentFilter中传入广播名称

## 接收系统消息
Android系统内置很多系统广播，可以通过监听这些广播获取手机的状态信息，比如网络状态变化:

需要先在`AndroidManifest.xml`文件中添加网络权限`
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"></uses-permission>
`

```
public class MainActivity extends AppCompatActivity {

    private IntentFilter intentFilter;
    private NetworkChangeReceiver networkChangeReceiver;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        // 添加Intent选择器
        intentFilter = new IntentFilter();
        intentFilter.addAction("android.net.conn.CONNECTIVITY_CHANGE");
        // 注册广播
        networkChangeReceiver = new NetworkChangeReceiver();
        registerReceiver(networkChangeReceiver,intentFilter);
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        // 注销广播
        unregisterReceiver(networkChangeReceiver);
    }

    class NetworkChangeReceiver extends BroadcastReceiver{
        @Override
        public void onReceive(Context context, Intent intent) {
            ConnectivityManager connectivityManager = (ConnectivityManager)getSystemService(Context.CONNECTIVITY_SERVICE);
            NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo();
            if (networkInfo != null && networkInfo.isAvailable()){
                Toast.makeText(context,"network is available",Toast.LENGTH_SHORT).show();
            }else {
                Toast.makeText(context,"network is unavaiable",Toast.LENGTH_SHORT).show();
            }
        }
    }
}
```
定义一个内部类`NetworkChangeReceiver`,继承自`BroadcastReceiver`，并重写`onReceive()`方法，当网络发生变化时，会调用这个方法。在`onReceive()`方法中，先通过`getSystemService()`方法得到`ConnectivityManager`的使用，这是一个系统服务类，用户管理网络连接，接着调用它的`getActivityNetworkInfo()`方法获取到`NetworkInfo`的实例，并调用`NetworkInfo`的`isAvailable`方法，可以判断当前是否有网络
**这里采用动态注册的方法，使用`IntentFilter`添加系统的广播名称,使用`registerReceiver()`方法注册，在`onDestroy()`方法中注销广播。**

## 发送广播
**发送标准广播：**`sendBroadcast(Intent)`
**发送有序广播：**`sendOrderedBroadcast(Intent,null);`第二个参数是跟权限有关的字符串，不需要可以直接传null
发送有序广播时，如果想在某个广播接收器中断发送，在`onReceive()`中使用`abortBroadcast();`方法。

## 使用本地广播
全局广播可以被其他应用程序接收到，也可以接收来自其他程序的广播。如果不想被其他程序所接收，可以使用本地广播。
本地广播是使用`LocalBroadcastManager`对广播进行管理，并提供了发送广播和注册广播的方法。发出的广播只在程序内部进行传递，广播接收器也只接收来自本程序发出的广播，**本地广播是无法通过静态注册的方式来接收的**,静态注册主要是为了让程序在未启动的情况下也能收到广播，发送本地广播时我们的程序已经启动了，因为也完全不需要静态注册的功能。上代码：

```
public class MainActivity extends AppCompatActivity {

    private IntentFilter intentFilter;

    private LocalReceiver localreceiver;

    private LocalBroadcastManager localBroadcastManager;

    private static final String ACTION = "com.example.local.Receiver";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

       // 获取本地广播管理实例
        localBroadcastManager =  LocalBroadcastManager.getInstance(this);
        // 添加Intent选择器
        intentFilter = new IntentFilter();
        intentFilter.addAction(ACTION);
        // 注册广播
        localreceiver = new LocalReceiver();
        localBroadcastManager.registerReceiver(localreceiver,intentFilter);

        // 发送广播
        findViewById(R.id.sendMessage).setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                Intent intent = new Intent(ACTION);
                localBroadcastManager.sendBroadcast(intent);
            }
        });
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        // 注销广播
       localBroadcastManager.unregisterReceiver(localreceiver);
    }

    class LocalReceiver extends BroadcastReceiver{
        @Override
        public void onReceive(Context context, Intent intent) {
            Toast.makeText(context,"接收到本地消息",Toast.LENGTH_SHORT).show();
        }
    }
}
```
首先获取本地广播`LocalBroadcastManager`的实例，之后注册和注销都通过这个实例类进行调用。

### 本地广播的优势
* 广播不会离开我们的程序，不用担心数据泄露问题
* 其他程序的广播无法发送到我们内部，不需要担心有安全漏洞的问题
* 本地广播比发送系统全局广播会更高效


